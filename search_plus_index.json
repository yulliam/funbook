{"./":{"url":"./","title":"Introduction","keywords":"","body":"My Awesome Book This file file serves as your book's preface, a great place to describe your book's content and ideas. Welcome ！ "},"第1章_基础知识/1_学习的方法.html":{"url":"第1章_基础知识/1_学习的方法.html","title":"1_学习的方法","keywords":"","body":"学习的方法 一.学习也是一种能力 　　看到这个标题，有人会说：“学习，谁不会?”的确，学习就像吃饭睡觉一样，是人的一种本能，人人都有学习的能力。我们在刚出生的时候，什么也不知道，是一张真正的白纸，我们靠学习的本能，学会了走路、说话、穿衣服…后来，我们上学了，老师把书本上的知识一点一点灌输到我们的脑子里，我们掌握的知识越来越多，与此同时，我们学习能力却好像越来越差了，习惯了被别人喂饱，似乎忘记了怎么来喂自己了。 　学习本来只是一种本能，算不上什么能力，然而，经过二十多年的不断学习，学习反而成为了一种真正的能力，因为我们慢慢失去了它，它就更显得珍贵。 　在学校里我们基本上被动式学习，然而走出了象牙塔之后，不会再有人对你负责，不会有人主动教你，我们需要主动的学习。所谓的学习能力，其实就是自主学习的能力。 　几年前，曾有一本风靡管理界的书，叫《第五项修炼》，这本书倡导建立学习型组织，因为从长远来看，一个组织唯一可持续的竞争优秀，就是比竞争对手更快更好的学习能力。 　一个公司如此，一个人又何尝不是如此?众所周知现在是一个知识爆炸的时候代，知识更新非常快。据说，一个大学毕业生所学习到的知识，在毕业之后的2年内，有效的不过剩下5%，更何况我们的学校与社会需要严重脱轨。我们赖以立足的，不在于我们现在掌握了多少知识，而是我们有多强的学习能力! 　学习不但是一种能力，而且是一种至关重要的能力，而这种能力的核心，就是学习的方法和心态。 二.买书是最划算的投资 　　古人云：“书中自有黄金屋，书中自的颜如玉。”这说明先贤们早就认识到，买书是最划算的投资了。 　当我刚出道的时候，拿着非常微薄的工资，有一次我向主管抱怨道：“现在的书真贵啊，这点工资连饭都吃不起，更别说买书了!”主管对我说：“不要吝惜买书的钱，宁可忍着不吃饭，也不要忍着不买书，因为买书是回报率的最高的投资了。” 　主管的话让我非常震动。后来，我看到喜欢的书时，再有没有手软过。我不断的学习，开发能力也不断的提高，工资水平也获得了大幅度的提高。一年后，我一个月工资的涨幅，就足够买两年的书了。你说，还有比这更划算的投资吗? 　一本书，哪怕只有一页纸是有用的，它将所产生的潜在价值，也会远远超过书本身的价格。当然，书不在多，能踏踏实实消化掉一本好书，可能比泛泛而读10本普通书，要更有价值得多。 三.多读经典书 　　十年前，我刚进入IT行业的时候，真是求知渴，每星期都要往购书中心跑，可惜的是，那时给程序员看的书不像现在这么多，高质量的书就更少了。当时我印象中比较经典的书籍就是《Windows程序设计》、《COM本质论》、《Java编程思想》，还有就是谭浩强的《C语言程序设计》。其它充斥书架的，就是类似于《21天精通XXX》、《XXX从入门到精通》、《XX宝典》这样的书籍。 　回首往昔，令我比较郁闷的一件事就是在我最有学习动力的时候，看的高质量的书籍太少，就好像是在长身体的时候，天天吃的是没营养的泡面。当然，这跟没有人指导也有很大的关系，独自一个人学习，让我走了很多的弯路。 　软件开发方面的书籍，我大致将其分为三类： 　　(1)浅显的入门类书籍。 　这类书的标题往往是《XX天精通XXX》、《XXX从入门到精通》、《XX开发实战》等，这类书往往从软件的安装讲起，喜欢翻译帮助文件。有人批评这类书为烂书、毫无价值，这并不公平。至少我本人，也曾从这些书中学到一些东西。即使是21天系列书，也有适合看的人群，只不过，它一般也就只能看21天而已，过后就可以扔到垃圾堆。这类书只适于还没有入门的初学者，从中学到一些入门的招式。这种书在刚起步的时候一般买上一本就可以了。如果你善于使用搜索引擎，这一本书也可以省了。 　　(2)国内外高手写的实战类书籍。 　这类书实战性很强，把技术及原理讲得很透彻。比如《windows环境下32位汇编语言程序设计》、《深入解析MFC》、《Delphi深度探索》、《深入浅出WPF》、《深入剖析Asp.net组件设计》等。以前这类书都是从国外翻译或从台湾引进，现在国内高手越来越多，出自国内作者的也越来越多。这类书如果在你学习的每个方向看个两三本，并且通过实践消化掉，那么毫无疑问，你会成为一个优秀的程序员。 　　(3)国外大牛写的、揭露本质、有丰富思想的书。 　这类书就是所谓的经典书了，例如《代码大全》、《编程珠玑》、《设计模式》、《重构》、《代码整洁之道》等。经典书就像一个有深度、有思想的朋友，他会给你启发、每次阅读都会有新的收获，这类书具有真正的收藏价值。看经典书永远是正确的选择，它绝不会浪费你的时间，因为经典书是无数人沙里淘金、帮你挑选过的结果。 　然而，阅读这类书并不是一件容易的事情，读者需要有丰富的开发经验，才能与作者产生共鸣。真正能消化经典书的人其实不多，这就好像饮酒，一个新手无论如何也品不出葡萄美酒的醇香。在酒桌上，人人都把杯中酒一饮而尽，当有人点评“这个酒不错”的时候，我只能无奈的苦笑一番，真的是甘苦自知。 　如果一本经典书你看得很辛苦，很有可能就是因为你功力未够，这种情况下不要着急，慢点来，不妨先将其先束之高阁，多看看第二类实战型书籍，过一段时间再回头来看，也许你会有新的惊喜。 四.不要在上班时间看书 　　一个善于学习的人，首先要善于利用一切时间来学习。不知是伟大的雷锋叔叔还是鲁迅爷爷曾经说过：“时间就像海绵里的水，只要愿挤，总还是有的。”然而，当我们从上班时间中挤时间学习时，就千万要注意了，不要在上班时间看书! 　上班时间看书不但是一件很敏感的事情，而且非常吸引眼球，很快就会引起周遭的不爽。首先老板心里不爽，他想：“我给你钱是让你来工作的，不是来学习的!”;其次同事们也不爽：“我们工作都做不完，瞧，这小子真闲哪!”用不了多久，你就会成为被众人排斥的异类。 　当然，你可能会说，“我工作已经做完了，经理没有安排，当然可以学习了”，其实不然。你完成了一件事情，不等于所有的事情都完成了。一个优秀的员工，应该是主动要工作，而不是被动的等工作。工作完成以后，你至少还可以： 　　(1)主动汇报给你的经理，请他来检查你的成果，并安排新的任务; 　(2)如果公司这一段时间确实比较闲，没有什么具体的任务，可以进行代码重构、优化; 　(3)你还可以主动请缨，承担额外的工作或更艰巨的任务。 　(4)如果一定要学习，也只能对着电脑屏幕来学习，纸质书最多只能拿来翻阅一下，而不能一直捧着，以免影响到其他人的情绪。 五.只学习与工作相关的东西 　　我曾发现不少程序员在学习方面找不到方向，一会学学C#，一会学学Java，看了最新的编程语言排行榜，又觉得该学C++。这样左抓抓，右挠挠，只会让你觉得更痒。 　学习最忌三心二意。俗话说：“伤其十指不如断其一指”，每门都学一点，还不如专心学好一个方向。这个道理谁都懂，可是又该学哪个方向呢?难道只能跟着感觉走吗? 　不!最实际的方向，应该跟着工作走，工作需要什么，我们就学什么，把工作需要的技能熟练掌握。我们为什么要学习和工作弱相关的东西呢?是为了转行或跳槽吗?可是，如果我们连现在本职工作都不能做好，又怎么能保证到新的岗位、用新学的技能就可以做得更好呢? 　学习与工作需要的的东西，有很多好处： 　　首先，可以集中精力，在某一方面钻研得更加深入。所谓“百招会不如一招绝”，有了绝招，你还怕不能在“武林”立足吗?《天龙八部》中的慕容复武功博学无比，最后还不是被只会一招六脉神剑的段誉打得落花流水? 　　其次，可以学得更快、更深入，因为学习更具有针对性，而且可以立即在工作中运用，可以马上检验出学习的效果，对存在的问题可以进行深入的研究，因此掌握的知识也会更加的牢固。 　　第三，学习与工作结合在一起，工作时间也就成了学习时间，这样突破了三个8小的限制。有人说，我们每天所有拥有的时间可以分为三个8小时，工作8小时，睡觉8小时，另外还有8小时自己可以自由支配的时间。工作和睡觉的两个8小时大家都一样，决定人生高度的是另外这个8小时。当我们把学习的焦点放到与工作相关的知识上时，工作时间中的很大一部分，同时也就成了宝贵的学习时间，这真是一举两得的美事啊。 六.织网式的学习 　　知识的广度和深度都很重要。作为一个程序员，深入把握技术细节，是写出优质代码的保证。但对于一个项目经理而言，知识的广度更显重要。项目中碰到的问题往往是综合性的，只有具有广博的知识，才能快速的对问题进行分析和定位。在程序员通往项目经理的道路上，我们必须有意识的扩大自己的知识面，形成更完善的知识体系。 　每个人的知识体系就好比是一张网，我们学习其实就是要织这样一张网。 我曾看过渔网的编织过程，渔网虽大，也是一个结点起步，一个点一个点的编出来的，编织的过程中，始终只有一根主线。 　学习又何尝不是这样，知识体系的大网也是由许多小的结点组成，要结这样一张网，只能由一个点起步。牵住一条主线，织出一个个的点，由点带出面，最后才能形成这张大网。 　我曾经编写过一个网络信息采集软件，这个软件可以从具有列表页网站中按字段设置采集信息，支持自定义字段、页面多级关联、下载附件、支持多种数据库、可视化定义等特性。刚开始时，觉得这个软件也是一个比较大的功能点而已，后来发现这个不起眼的功能关联着大量的知识点，在开发过程中， 我顺藤摸瓜，各个击破，对很多知识点进行了细致的学习研究，软件开发完成后，个人的知识体系网也进一步得到了补充和完善。 七.问题是最好的学习机会 　　日本经营之神松下幸之助曾经说过：“工作就是不断发现问题、分析问题、最终解决问题的一个过程，晋升之门将永远为那些随时解决问题的人敞开着。”可见，工作过程中有问题是正常，没有问题那才是真正的问题。在发生问题能时，能勇于面对问题、解决问题的人，才是公司真正的核心骨干。 　现实中，很多人总是千方百计回避问题，当上司安排一项艰巨的任务时，也是想尽办法推托。殊不知，对于个人而言，其实问题是最好的学习机会。往往那些愿意接受困难工作的人，能力会变得越来越强，那就是因为他们在克服困难的过程中取得了巨大的进步。 　有一次，一位项目经理对我说：“有一个问题，客户有一台HP服务器要装磁盘阵列，没人会做，怎么办啊?”“可以学啊，没有人愿意去吗?”“我都问了，没人想去。”“哦，正好明天我有时间，我也没装过磁盘阵列，那我明天去学着弄一下。”我说的是真心话。第二天早上，当我准备出发时，项目经理告诉我不用我去了，因为项目组好几个同事都想去“学着弄一下”。 　结果服务器很快就装好了，远远没有之前大家想像的那么困难嘛。更重要的是，在解决这个问题的过程中，大家都学会了怎么装磁盘阵列。 　碰到困难时，迎难而上吧，千万不要拒绝这个最好的学习机会! 八.经常思考总结 　　子曰：“学而不思则罔”。只学习不思考，就会迷惑，难以把握事情的本质。这就好比一个学武之人，只习得其形，而未得其神，难以成为真正的高手。 　一个程序员从入门，到成为高手的过程中，往往要经过几次顿悟。顿悟会让你跳出知识的丛林，一切豁然开朗，仿佛打通了全身的奇经八脉一般奇妙。记得我有一次，顿悟到了一个很简单的结论：“原来高级编程语言中的类库是封装了Windows API来实现的。”后来碰到一些自带类库无法实现的功能时，我就会想到，其实可以通过调用Windows API来实现。利用这个思路，我解决了一些看起来很难的问题，得到老板的赏识，从而很快获得提升。 　顿悟非常可贵，然而它不是随便发生的，而是经过一次次苦苦思索之后、灵光闪现的结果。思考的过程，其实就是将外在的知识内化为自己的知识的过程，而顿悟，则是批量的实现这种内化，将无数个知识点连接在一起，达到融会贯通的境界。 九、克服“高原现象” 　　爱学习的人都会有这样的经历，学习持续了一段时间之后，往往会有一个瓶颈期，长时间似乎很久没有什么进步，于是内心非常着急。 　这种情况实际上这是由人的学习规律决定的一种“高原现象”。据研究，学习者在刚开始进步快，随后有一个明显的或长或短的进步停顿期，后期进步慢，中间的停顿期叫高原期。 　　在我看来，高原期实质是一个消化期，由于前期的学习积累了太多的知识点，这些知识点在大脑中乱作一团，还没有形成一个知识体系。这时需要一定的时间来消化它，将它融会贯通，经常思考总结可以快速帮你跨过高原期。 　在处于高原期的时候，还可以换一个相关的方向来学习，例如编程语言学不下去了，你可以学习一下设计模式，设计模式也学不下去了，再换成数据库。通过学习这些相关的知识，不但补齐了知识体系中的短板，而且各个知识点之间可以互相启发，帮助你实现顿悟，跨过高原期。 十、学习要有好心态 　　(1)学习要静心 　急于求成是学习过程中普遍存在的一种心态。这可以理解，毕竟作为一个程序员，要学的东西实在太多了，而社会又是那样的浮躁，让人觉得一切都是那样的不安全、不确定，似乎只有学得快一点，才能跟上社会的脚步。 　可是“欲速则不达”，想快快的学，往往会形成东一榔头、西一棒槌的学习方式，每一个点都没有吃透。心沉不下去，知识也会沉不下去。要想成为真正的高手，只能静下心来，一步一个脚印的攀登。 　　(2)学习是一个持续一生的过程 　人生的过程，就是一个自我完善过程。 　孔子曾经说：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。”可见孔子也不是天生的圣人，也在不停的学习、进步，从“志于学”到最后“从心所欲，不逾矩”，孔子一共花了55年的时间。 　作为一个程序员，更是需要不断更新自己的知识。我们所知道的东西，就像一个白色的圆圈，圈外则是黑暗的未知的世界。当圆圈越大，所接触到的黑暗部分就越多。我们只有不停的学习，打破更多的黑暗，找到更多光明。 　　(3)保持饥饿，保持愚蠢 　看了《乔布斯传》之后，我最喜欢的一句话是“求知若饥，虚心若愚”(Stay Hungry,Stay Foolish)，其实我更喜欢它更原生态的翻译“保持饥饿，保持愚蠢”。我们只有认识到自己还很饥饿和愚蠢，才会像没吃饱一样，由衷的需要学习、爱上学习。 　当然，知易行难，知行合一才是学习的最高境界。我也始终是一个学习者，一直在路上。 "},"第1章_基础知识/2_markdown语法.html":{"url":"第1章_基础知识/2_markdown语法.html","title":"2_markdown语法","keywords":"","body":"Markdown基本语法 ‌ Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 ‌ 相比WYSIWYG编辑器 ‌ 优点： 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 ‌ 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。 2、有些平台不支持Markdown编辑模式。 ‌ 还好，简书是支持Markdown编辑模式的。 开启方式：设置->默认编辑器->Markdown编辑器 ‌ 一、标题 ‌ 在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 ‌ 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 ‌ 示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 ‌ 效果如下： ‌ 这是一级标题 ‌ 这是二级标题 ‌ 这是三级标题 ‌ 这是四级标题 ‌ 这是五级标题 ‌ 这是六级标题 ‌ 二、字体 ‌ 加粗 ‌ 要加粗的文字左右分别用两个*号包起来 ‌ 斜体 ‌ 要倾斜的文字左右分别用一个*号包起来 ‌ 斜体加粗 ‌ 要倾斜和加粗的文字左右分别用三个*号包起来 ‌ 删除线 ‌ 要加删除线的文字左右分别用两个~~号包起来 ‌ 示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ ‌ 效果如下： ‌ 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 ‌ 三、引用 ‌ 在引用的文字前加>即可。引用也可以嵌套，如加两个>>三个>>> n个... 貌似可以一直加下去，但没神马卵用 ‌ 示例： >这是引用的内容 >>这是引用的内容 >>>>>>>>>>这是引用的内容 ‌ 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 ‌ 四、分割线 ‌ 三个或者三个以上的 - 或者 * 都可以。 ‌ 示例： --- ---- *** ***** ‌ 效果如下： 可以看到，显示效果是一样的。 ‌ 五、图片 ‌ 语法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ‌ 示例： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419&fm=27&gp=0.jpg \"区块链\") ‌ 效果如下： ‌ blockchain ‌ 上传本地图片直接点击导航栏的图片标志，选择图片即可 ‌ markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。 关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。markdown图床 ‌ 六、超链接 ‌ 语法： [超链接名](超链接地址 \"超链接title\") title可加可不加 ‌ 示例： [简书](http://jianshu.com) [百度](http://baidu.com) ‌ 效果如下： ‌ 简书 百度 ‌ 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 超链接名 示例 简书 ‌ 七、列表 ‌ 无序列表 ‌ 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 ‌ 效果如下： ‌ 列表内容 列表内容 列表内容 ‌ 有序列表 ‌ 语法： 数字加点 1. 列表内容 2. 列表内容 3. 列表内容 注意：序号跟内容之间要有空格 ‌ 效果如下： ‌ 列表内容 列表内容 列表内容 ‌ 列表嵌套 ‌ 上一级和下一级之间敲三个空格即可 ‌ 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 ‌ 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 ‌ 八、表格 ‌ 语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 ‌ 示例： 姓名|技能|排行 --|:--:|--: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟 ‌ 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 ‌ 九、代码 ‌ 语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` ‌ 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 (```) 代码... 代码... 代码... (```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 ‌ 示例： ‌ 单行代码 `create database hero;` ‌ 代码块 (```) function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); (```) ‌ 效果如下： ‌ 单行代码 ‌ create database hero; ‌ 代码块 function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); ‌ 十、流程图 ```flow st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op & ``` ‌ 效果如下： 简书不支持流程图，所以截了个图 "},"第1章_基础知识/3_gitbook使用方法.html":{"url":"第1章_基础知识/3_gitbook使用方法.html","title":"3_gitbook使用方法","keywords":"","body":"gitbook使用方法 GitBook 是使用 GitHub / Git 和 Markdown（或AsciiDoc）构建漂亮书籍的命令行工具（和Node.js库）。 GitBook 可以将您的内容作为网站（可定制和可扩展）或电子书（PDF，ePub或Mobi）输出。 GitBook.com 是使用 GitBook 格式创建和托管图书的在线平台。它提供托管，协作功能和易于使用的编辑器。 GitBook 安装 本地安装 环境要求 安装 GitBook 是很简单的。您的系统只需要满足这两个要求： NodeJS（推荐使用v4.0.0及以上版本） Windows，Linux，Unix 或 Mac OS X 通过NPM安装 安装 GitBook 的最好办法是通过 NPM。在终端提示符下，只需运行以下命令即可安装 GitBook： $ npm install gitbook-cli -g gitbook-cli 是 GitBook 的一个命令行工具。它将自动安装所需版本的 GitBook 来构建一本书。 执行下面的命令，查看 GitBook 版本，以验证安装成功。 $ gitbook -V 安装历史版本 gitbook-cli 可以轻松下载并安装其他版本的GitBook来测试您的书籍： $ gitbook fetch beta 使用 gitbook ls-remote 会列举可以下载的版本。 创建一本书 初始化 GitBook可以设置一个样板书： $ gitbook init 如果您希望将书籍创建到一个新目录中，可以通过运行 gitbook init ./directory 这样做。 构建 使用下面的命令，会在项目的目录下生成一个 _book 目录，里面的内容为静态站点的资源文件： $ gitbook build Debugging 您可以使用选项 --log=debug 和 --debug 来获取更好的错误消息（使用堆栈跟踪）。例如： $ gitbook build ./ --log=debug --debug 启动服务 使用下列命令会运行一个 web 服务, 通过 http://localhost:4000/ 可以预览书籍 $ gitbook serve GitBook 命令 这里主要介绍一下 GitBook 的命令行工具 gitbook-cli 的一些命令, 首先说明两点: gitbook-cli 和 gitbook 是两个软件 gitbook-cli 会将下载的 gitbook 的不同版本放到 ~/.gitbook中, 可以通过设置GITBOOK_DIR环境变量来指定另外的文件夹 列出 gitbook 所有的命令 gitbook help 输出 gitbook-cli 的帮助信息 gitbook --help 生成静态网页 gitbook build 生成静态网页并运行服务器 gitbook serve 生成时指定gitbook的版本, 本地没有会先下载 gitbook build --gitbook=2.0.1 列出本地所有的gitbook版本 gitbook ls 列出远程可用的gitbook版本 gitbook ls-remote 安装对应的gitbook版本 gitbook fetch 标签/版本号 更新到gitbook的最新版本 gitbook update 卸载对应的gitbook版本 gitbook uninstall 2.0.1 指定log的级别 gitbook build --log=debug 输出错误信息 gitbook builid --debug Gitbook 目录结构 GitBook 项目结构 GitBook使用简单的目录结构。在 SUMMARY （即 SUMMARY.md 文件）中列出的所有 Markdown / Asciidoc 文件将被转换为 HTML。多语言书籍结构略有不同。 一个基本的 GitBook 电子书结构通常如下： . ├── book.json ├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md GitBook 特殊文件的功能： 静态文件和图片 静态文件是在 SUMMARY.md 中未列出的文件。除非被忽略，否则所有静态文件都将复制到输出路径。 忽略文件和文件夹 GitBook将读取 .gitignore，.bookignore 和 .ignore 文件，以获取要过滤的文件和文件夹。这些文件中的格式遵循 .gitignore 的规则： # This is a comment # Ignore the file test.md test.md # Ignore everything in the directory \"bin\" bin/* 项目与子目录集成 对于软件项目，您可以使用子目录（如 docs/ ）来存储项目文档的图书。您可以配置根选项来指示 GitBook 可以找到该图书文件的文件夹： . ├── book.json └── docs/ ├── README.md └── SUMMARY.md 在 book.json 中配置以下内容： { \"root\": \"./docs\" } Summary GitBook 使用 SUMMARY.md 文件来定义本书的章节和子章节的结构。 SUMMARY.md 文件用于生成本书的目录。 SUMMARY.md 的格式是一个链接列表。链接的标题将作为章节的标题，链接的目标是该章节文件的路径。 向父章节添加嵌套列表将创建子章节。 简单示例： # Summary * [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) * [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) 每章都有一个专用页面（part#/README.md），并分为子章节。 锚点 目录中的章节可以使用锚点指向文件的特定部分。 # Summary ### Part I * [Part I](part1/README.md) * [Writing is nice](part1/README.md#writing) * [GitBook is nice](part1/README.md#gitbook) * [Part II](part2/README.md) * [We love feedback](part2/README.md#feedback) * [Better tools for authors](part2/README.md#tools) 部分 目录可以分为以标题或水平线 ---- 分隔的部分： # Summary ### Part I * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) ---- * [Last part without title](part3/title.md) Parts 只是章节组，没有专用页面，但根据主题，它将在导航中显示。 页面 Markdown 语法 默认情况下，GitBook 的大多数文件都使用 Markdown 语法。 GitBook 推荐使用这种语法。所使用的语法类似于 GitHub Flavored Markdown syntax 。 此外，你还可以选择 AsciiDoc 语法。 页面内容示例： # Title of the chapter This is a great introduction. ## Section 1 Markdown will dictates _most_ of your **book's structure** ## Section 2 ... 页面前言 页面可以包含一个可选的前言。它可以用于定义页面的描述。前面的事情必须是文件中的第一件事，必须采取在三虚线之间设置的有效YAML的形式。这是一个基本的例子： --- description: This is a short description of my page --- # The content of my page ... Glossary 允许您指定要显示为注释的术语及其各自的定义。根据这些术语，GitBook 将自动构建索引并突出显示这些术语。 GLOSSARY.md 的格式是 h2 标题的列表，以及描述段落： ## Term Definition for this term ## Another term With it's definition, this can contain bold text and all other kinds of inline markup ... Gitbook 配置 GitBook 允许您使用灵活的配置自定义您的电子书。 这些选项在 book.json 文件中指定。对于不熟悉 JSON 语法的作者，您可以使用 JSONlint 等工具验证语法。 常规设置 author 作者姓名，在http://GitBook.com上，这个字段是预先填写的。 例： \"author\" : \"victor zhang\" description 电子书的描述，默认值是从 README 中提取出来的。在http://GitBook.com上，这个字段是预先填写的。 例： \"description\" : \"Gitbook 教程\" direction 文本的方向。可以是 rtl 或 ltr，默认值取决于语言的值。 例： \"direction\" : \"ltr\" gitbook 应该使用的GitBook版本。使用SemVer规范，接受类似于 >=3.0.0 的条件。 例： \"gitbook\" : \"3.0.0\", \"gitbook\" : \">=3.0.0\" language Gitbook使用的语言, 版本2.6.4中可选的语言如下： en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 例： \"language\" : \"zh-hans\", links 在左侧导航栏添加链接信息 例： \"links\" : { \"sidebar\" : { \"Home\" : \"https://github.com/dunwu/gitbook-notes\" } } root 包含所有图书文件的根文件夹的路径， book.json 文件除外。 例： \"root\" : \"./docs\", structure 指定 Readme、Summary、Glossary 和 Languages 对应的文件名。 styles 自定义页面样式， 默认情况下各generator对应的css文件 例： \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 例如要使 h1、h2 标签有下边框， 可以在 website.css 中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } title 电子书的书名，默认值是从 README 中提取出来的。在 http://GitBook.com 上，这个字段是预先填写的。 例： \"title\" : \"gitbook-notes\", plugins 插件及其配置在 book.json 中指定。有关详细信息。 自 3.0.0 版本开始，GitBook 可以使用主题。有关详细信息，请参阅 the theming section 。 添加插件 \"plugins\": [ \"splitter\" ] 添加新插件之后需要运行 gitbook install 来安装新的插件 去除自带插件 Gitbook 默认带有 5 个插件： highlight search sharing font-settings livereload \"plugins\": [ \"-search\" ] structure 除了 root 属性之外，您可以指定 Readme，Summary，Glossary 和 Languages 的名称（而不是使用默认名称，如README.md）。这些文件必须在项目的根目录下（或 root 的根目录，如果你在 book.json 中配置了 root 属性）。不接受的路径，如：dir / MY_README.md。 pdf 可以使用 book.json 中的一组选项来定制PDF输出： 生成电子书 GitBook 可以生成一个网站，但也可以输出内容作为电子书（ePub，Mobi，PDF）。 # Generate a PDF file $ gitbook pdf ./ ./mybook.pdf # Generate an ePub file $ gitbook epub ./ ./mybook.epub # Generate a Mobi file $ gitbook mobi ./ ./mybook.mobi 安装 ebook-convert ebook-convert 可以用来生成电子书（epub，mobi，pdf）。 GNU/Linux 安装 Calibre application. $ sudo aptitude install calibre 在一些 GNU / Linux 发行版中，节点被安装为 nodejs，您需要手动创建一个符号链接： $sudo ln -s /usr/bin/nodejs /usr/bin/node 封面 封面用于所有电子书格式。您可以自己提供一个，也可以使用 autocover plugin 生成一个。 要提供封面，请将 cover.jpg 文件放在书本的根目录下。添加一个 cover_small.jpg 将指定一个较小版本的封面。封面应为 JPEG 文件。 好的封面应该遵守以下准则： cover.jpg 的尺寸为 1800x2360 像素，cover_small.jpg 为 200x262 没有边界 清晰可见的书名 任何重要的文字应该在小版本中可见 "},"第1章_基础知识/4_命名规范.html":{"url":"第1章_基础知识/4_命名规范.html","title":"4_命名规范","keywords":"","body":"命名规范和编码规范 转载：http://blog.csdn.net/crazy1235/article/details/51346027 有过团队开发经验的人都知道，如果没有一定的规范可行，那么代码看起来将是苦不堪言，甚至是乱七八糟。 下面就介绍一下，我个人编码过程中使用到的规范，供大家参考~~ 命名规则介绍 命名规范要望文知义，简单明了。 命名规范定制太多，就会让人心烦，反而没人遵守了。 ---《APP研发录》 先介绍两种命名规则： 驼峰命名法：又称小驼峰命名法。除了首个单词首字母小写除外，其余所有单词所有首字母都要大写。 帕斯卡命名法：又称大驼峰命名法。所有单词首字母大写。 包名的命名规范 包名一律小写 建议采用如下规则：【com】.【公司名/组织名】.【项目名称】.【模块名】 比如：com.jacksen.mvp.demo。然后在这个目录下根据业务逻辑进行分层。 常见的包分层结构如下： com.xxx.xxx.view –> 自定义view 或者是View接口 com.xxx.xxx.activities –> activity类 com.xxx.xxx.fragments –> fragment类 com.xxx.xxx.adapter –> 适配器相关 com.xxx.xxx.utils –> 公共工具类 com.xxx.xxx.bean –> 实体类 com.xxx.xxx.service –> service服务 com.xxx.xxx.broadcast –> 广播接收器 com.xxx.xxx.db –> 数据库操作类 com.xxx.xxx.persenter –> 中间对象 com.xxx.xxx.model –> 数据处理类 类的命名规范 Android中类的命名与JAVA开发采用一致的规范即可。 大驼峰命名法，即所有单词首字母大写。 Activity –> xxxActivity.java Application –> xxxApplication.java Fragment –> xxxFragment.java Service –> xxxService.java BroadcastReceiver –> xxxBroReceiver.java ContentProvider –> xxxProvider.java Adapter –> xxxAdapter.java Handler –> xxxHandler.java 接口 –> xxxInter.java 接口实现类 –> xxxImpl.java Persenter –> xxxPersenter.java 公共父类 –> BaseActivity.java、BaseFragment.java、- BaseAdapter.java等 util类 –> LogUtil.java 数据库类 –> BaseSQLiteDBHelper.java 变量的命名规范 采用驼峰命名规则。 Java普通变量： resultString userBean loginPresenter Android控件变量： loginBtn inputPwdEt showNameTv 有些人建议采用【控件缩写】+【控件逻辑名称】的方式，比如btnLogin。不过我个人比较习惯反过来写，比如loginBtn。与类的命名类似，把逻辑名称写在前面。 常用控件的缩写 控件 布局文件中缩写 代码中缩写 LinearLayout xxx_layout xxxLLayout RelativeLayout xxx_layout xxxRLayout FrameLayout xxx_layout xxxFLayout TextView xxx_tv xxxTv EditText xxx_et xxxEt Button xxx_btn xxxBtn ImageView xxx_iv xxxIv CheckBox xxx_chk xxxChk RadioButton xxx_rbtn xxxRbtn ProgressBar xxx_pbar xxxPbar ListView xxx_lv xxxLv WebView xxx_wv xxxWv GridView xxx_gv xxxGv 常见单词的缩写： 单词 缩写 icon ic background bg foreground fg initial init information info success succ failure fail error err image img library lib message msg password pwd length len buffer buf position pos 常量命名： 全部单词采用大写，每个单词之间用“_”分割。 例如： public static final String API_URL = \"http://apis.baidu.com/heweather/weather/free\"; 1 1 方法的命名规范 与java开发类似，采用驼峰命名规则。首单词首字母小写，其余单词首字母大写。尽量不要使用下划线。 举例： setxxx() getxxx() loginxxx() onCreate() onDestory() isxxx() –> 返回值是boolean类型 checkxxx() 资源的命名规范 全部采用小写，单词之间使用下划线分割。 布局文件： activity_login.xml fragment_first_tab.xml item_choose_city.xml dialog_choose_city.xml common_footer.xml popup_xxx.xml 控件ID： 上面【常用控件的缩写】表格中基本列出了常用控件的ID写法。 login_btn input_phone_et input_pwd_et login_pbar drawable目录下的命名规范 全部单词小写，单词之间采用下划线分割。 图标 – > ic_xxx.png –> ic_logo.png 背景图 –> bg_xxx.jpg –> bg_splash.jpg selector –> selector_login_btn.xml shape –> shape_login_btn.xml 图片状态 –> bg_login_btn_pressed.jpg & - bg_login_btn_unpressed.jpg anim目录下的命名规范 单词全部小写，单词之间采用下划线分割。 fade_in.xml fade_out.xml slide_in_from_left.xml slide_in_from_top.xml slide_out_to_right.xml slide_out_to_bottom.xml 编码规范 代码中尽量不要出现中文。注释和除外。代码中通过strings.xml引用来显示中文。 控件声明放在activity级别，这样在activity其他地方可以使用。 在一个View.OnClickListener中处理所有的点击事件逻辑，这样看起来很集中和直观。 strings.xml中使用%1sd等实现字符串的通配。 布局文件中的字体大小，都定义在dimens.xml中。 有关margin和padding的值也都放在dimens.xml中。 界面之间传值尽量使用intent方式。少用全局变量。 不建议在布局文件中添加点击事件。 数据类型转换一定要校验。 使用常量代替枚举。 实体不要在不同模块间共享，但是可以在统一模块下的不同页面共享。 建议采用左括号与方法名称在同一行的代码格式来进行代码的编写和格式化。貌似左括号在下一行是C#的形式。 业务稍微复杂一些，都有可能提炼一个BaseActivity或BaseFragment出来做为公共父类。 类注释一定要写，管家的方法也要写方法注释。常量尽量写注释。 项目中的命名规范和编码规范，是一个项目Leader前期需要准备的，也是一项必备技能。 制定好了规范，就要遵守，有了统一的规范，项目才好维护，相互之间才好review代码，便于开发与维护。 "},"第1章_基础知识/5_混淆.html":{"url":"第1章_基础知识/5_混淆.html","title":"5_混淆","keywords":"","body":"Android开发之代码混淆 应用混淆（ProGuard） ProGuard是一个免费的JAVA类文件压缩，优化，混淆器。 它探测并删除没有使用的类，字段，方法和属性，它删除没有用的说明并使用字节码得到最大优化，它使用无意义的名字重命名类，字段和方法。 我们先来介绍下ProGuard 我们为啥要使用ProGuard? 优化应用：创建紧凑的代码文档是为了更快的网络传输，快速装载和更小的内存占用； 防止反向：创建的程序和程序库很难使用反向工程； 预处理应用：充分利用JAVA的快捷加载的优点来提前检测和返回JAVA中存在的类文件。 有些什么参数可用？ -include {filename} 从指定的文件中读取配置参数 -basedirectory {directoryname} 指定基础目录为以后相对的档案文件 -injars {class_path} 指定要处理的应用程序jar,war,ear的目录 -outjars {class_path} 指定处理完后要输出的jar,war,ear目录的名称 -libraryjars {class_path} 指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 dontskipnonpubliclibraryclasses 指定不去忽略非公共的库类 dontskipnonpubliclibraryclassmebmbers 指定不去忽略可见的库类的成员 上面提到了Jar、war、ear三种文件 Jar、war、ear、在文件结构上，三者并没有什么不同，它们都采用zip或jar档案文件压缩格式。但是它们的使用目的有所区别： Jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。 War文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对jar文件进行封装，并把它作为小型服务程序（servlet）来访问。 Ear文件（扩展名为.Ear,Enterprise Application Archive）包含全部企业应用程序。在这种情形下，一个企业应用程序被定义为多个jar文件、资源、类和Web应用程序的集合。 每一种文件（.jar, .war, .ear）只能由应用服务器（application servers）、小型服务程序容器（servlet containers）、EJB容器（EJB containers）等进行处理。 有哪些保留选项？ 关键字[2] 关键字 描述 dontwarn dontwarn是一个和keep可以说是形影不离,尤其是处理引入的library时. keep 保留类和类中的成员，防止被混淆或移除 keepnames 保留类和类中的成员，防止被混淆，成员没有被引用会被移除 keepclassmembers 只保留类中的成员，防止被混淆或移除 keepclassmembernames 只保留类中的成员，防止被混淆，成员没有引用会被移除 keepclasseswithmembers 保留类和类中的成员，防止被混淆或移除，保留指明的成员 keepclasseswithmembernames 保留类和类中的成员，防止被混淆，保留指明的成员，成员没有引用会被移除 压缩 dontshrink 不压缩输入的类文件 printusage {filename} whyareyoukeeping {class_specification} 优化 -dontoptimize 不优化输入的类文件 -assumenosideeffects {class_specification} 优化时假设指定的方法，没有任何副作用 -allowaccessmodification 优化时允许访问并修改有修饰符的类和类的成员 混淆 -dontobfuscate 不混淆输入的类文件 -printmapping {filename} -applymapping {filename} 重用映射增加混淆 -obfuscationdictionary {filename} 使用给定文件中的关键字作为要混淆方法的名称 -overloadaggressively 混淆时应用侵入式重载 -useuniqueclassmembernames 确定统一的混淆类的成员名称来增加混淆 -flattenpackagehierarchy {package_name} 重新包装所有重命名的包并放在给定的单一包中 -repackageclass {package_name} 重新包装所有重命名的类文件中放在给定的单一包中 -dontusemixedcaseclassnames 混淆时不会产生形形色色的类名 -keepattributes {attribute_name,...} 保护给定的可选属性，例如LocalVariableTable（本地变量）, SourceFile（源文件）， InnerClasses（内部类） -renamesourcefileattribute {string} 设置源文件中给定的字符串常量 上面介绍了一下ProGuard的基本方法 下面来介绍一下Android中的混淆文件。 对应于项目下的proguard-rules.pro文件 基本配置项 1.指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 -libraryjars libs/apns_1.0.6.jar -libraryjars libs/armeabi/libBaiduMapSDK_v2_3_1.so -libraryjars libs/armeabi/liblocSDK4.so -libraryjars libs/core.jar -libraryjars libs/gesture-imageview.jar -libraryjars libs/gson-2.6.2.jar -libraryjars libs/infogracesound.jar -libraryjars libs/universal-image-loader-1.9.0.jar 方法： libraryjars jar路径 ->libraryjars 项目中导入的jar包等 现在Studio的话可以忽略此配置了。 2.不优化输入的class文件，默认情况下是启用优化的 #不优化输入的class文件，默认情况下是启用优化的 -dontoptimize 3.Proguard对你的代码进行迭代优化的次数 0~7，一直优化到代码不能被优化为止 #Proguard对你的代码进行迭代优化的次数 0~7，一直优化到代码不能被优化为止 -optimizationpasses 5 4.跳过库中非public的类，可以加快proguard处理速度；但是有些类库包含从public类中继承来的非public类。这时如果加了这条会产生一个warning(find classes) -skipnonpubliclibraryclasses 5.指定不去忽略非公共的库类 -dontskipnonpubliclibraryclasses 6.指定不去忽略包可见的库类的成员。 -dontskipnonpubliclibraryclassmembers 7.确定统一的混淆类的成员名称来增加混淆 -useuniqueclassmembernames 8.混淆时不会产生形形色色的类名 -dontusemixedcaseclassnames 9.混淆前认证,去掉可加快混淆速度 -dontpreverify 10.假如项目中有用到注解,保留注解，不混淆 -keepattributes *Annotation* Android中的配置项 1.保留所有的v4包中类不被混淆 -keep class android.support.v4.** 2.保留所有的v4包中接口不被混淆 -keep interface android.support.v4.** 3.保留系统中继承v4/v7包的类，不被混淆 -keep class android.support.** { *; } -keep class android.support.v4.** { *; } -keep public class * extends android.support.v4.** -keep interface android.support.v4.app.** { *; } -keep class android.support.v7.** { *; } -keep public class * extends android.support.v7.** -keep interface android.support.v7.app.** { *; } -dontwarn android.support.** 4.保留系统中继实现v4/v7包的接口，不被混淆 -keep public class * implements android.support.v4.** -dontwarn android.support.v4.** 5.所有的native方法不被混淆 -keepclasseswithmembers class * { native ; } 6.自定义View构造方法不混淆 -keepclasseswithmembers class * { public (android.content.Context); } -keepclasseswithmembers class * { public (android.content.Context,android.util.AttributeSet); } -keepclasseswithmembers class * { public (android.content.Context,android.util.AttributeSet,int); } 被Android Resource 文件引用到，名字已经固定，不能混淆。 7.枚举不被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } 8.release版不打印log -assumenosideeffects class android.util.Log { public static *** d(...); public static *** v(...); public static *** i(...); public static *** e(...); public static *** w(...); } 9.四大组件不能混淆 -dontwarn android.support.v4.** -keep class android.support.v4.app.** { *; } -keep interface android.support.v4.app.** { *; } -keep class android.support.v4.** { *; } -keep public class * extends android.app.Application -dontwarn android.support.v7.** -keep class android.support.v7.internal.** { *; } -keep interface android.support.v7.internal.** { *; } -keep class android.support.v7.** { *; } -keep public class * extends android.app.Activity -keep public class * extends android.app.Fragment -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference 10.Design包不混淆 -dontwarn android.support.design.** -keep class android.support.design.** { *; } -keep interface android.support.design.** { *; } -keep public class android.support.design.R$* { *; } 11.确保JavaBean不被混淆-否则Gson将无法将数据解析成具体对象 -keep class com.rair.circle.bean.** { *; } -keep class com.rair.circle.db.bean.** { *; } 12.不混淆资源类 -keepclassmembers class **.R$* { public static ; } 13.忽略警告 -ignorewarning 当我们使用第三方框架，jar包，如果配置混淆，都有对应的混淆配置提供。 例如Jpush(极光推送) 我们只要copy到项目混淆文件中就行 最后 混淆时是否记录日志 -verbose 1.apk包内所有 class 的内部结构 -dump class_files.txt 2.未混淆的类和成员 -printseeds seeds.txt 3.列出从 apk 中删除的代码 -printusage unused.txt 4.混淆前后的映射 -printmapping mapping.txt 参考配置 #######################-----app中-----############################ #如果使用了Gson之类的工具要使被它解析的JavaBean类即实体类不被混淆 #######################-----第三方-----############################ #######################-----WebView(项目中没有可以忽略)-----############################ #webView需要进行特殊处理 -keepclassmembers class fqcn.of.javascript.interface.for.Webview { public *; } -keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String); } -keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView, jav.lang.String); } #在app中与HTML5的JavaScript的交互进行特殊处理 #我们需要确保这些js要调用的原生方法不能够被混淆，于是我们需要做如下处理： -keepclassmembers class com.ljd.example.JSInterface { ; } #######################-----其他-----############################ # 删除代码中Log相关的代码 -assumenosideeffects class android.util.Log { public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...); } # 保持测试相关的代码 -dontnote junit.framework.** -dontnote junit.runner.** -dontwarn android.test.** -dontwarn android.support.test.** -dontwarn org.junit.** #######################-----基本-----############################ #指定代码的压缩级别 0 - 7(指定代码进行迭代优化的次数，在Android里面默认是5，这条指令也只有在可以优化时起作用。) -optimizationpasses 5 #混淆时不会产生形形色色的类名(混淆时不使用大小写混合类名,混淆后类名都为小写) -dontusemixedcaseclassnames #指定不去忽略非公共的库的类 #默认跳过，有些情况下编写的代码与类库中的类在同一个包下，并且持有包中内容的引用，此时就需要加入此条声明 -dontskipnonpubliclibraryclasses #指定不去忽略非公共的库的类的成员 -dontskipnonpubliclibraryclassmembers #Optimization is turned off by default. Dex does not like code run #hrough the ProGuard optimize and preverify steps (and performs some #of these optimizations on its own). #不进行优化，建议使用此选项，不优化输入的类文件（原因见上边的原英文注释） -dontoptimize #不做预检验，preverify是proguard的四个步骤之一 #Android不需要preverify，去掉这一步可以加快混淆速度 -dontpreverify #屏蔽警告 -ignorewarnings #指定混淆是采用的算法，后面的参数是一个过滤器 #这个过滤器是谷歌推荐的算法，一般不做更改 -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* #避免混淆Annotation、内部类、泛型、匿名类 -keepattributes *Annotation*,InnerClasses,Signature,EnclosingMethod #表示不混淆声明的两个类，这两个类我们基本也用不上，是接入Google原生的一些服务时使用的 -keep public class com.google.vending.licensing.ILicensingService -keep public class com.android.vending.licensing.ILicensingService #抛出异常时保留代码行号 -keepattributes SourceFile,LineNumberTable #重命名抛出异常时的文件名称,点击鼠标可以到达错误文件位置 -renamesourcefileattribute SourceFile #混淆时是否记录日志 -verbose #不混淆R文件中的所有静态字段，以保证正确找到每个资源的id -keepclassmembers class **.R$* { public static ; } #保留四大组件，自定义的Application等这些类不被混淆 -keep public class * extends android.app.Activity -keep public class * extends android.app.Fragment -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View #处理support包 -keep class android.support.** {*;} -dontnote android.support.** -dontwarn android.support.** #保留继承的 -keep public class * extends android.support.v4.** -keep public class * extends android.support.v7.** -keep public class * extends android.support.annotation.** #保留本地native方法不被混淆 -keepclasseswithmembernames class * { native ; } #保留枚举类不被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } #保持 Serializable 不被混淆并且enum 类也不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient ; !private ; !private ; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } #保留Parcelable序列化类不被混淆 -keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *; } #see http://proguard.sourceforge.net/manual/examples.html#beans #不混淆View中的setXxx()和getXxx()方法，以保证属性动画正常工作 -keep public class * extends android.view.View{ *** get*(); void set*(***); public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int); } #不混淆Activity中参数是View的方法，例如，一个控件通过android:onClick=\"clickMethodName\"绑定点击事件，混淆后会导致点击事件失效 -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } #保留Keep注解的类名和方法(最新的proguard-android.txt中包括了这个) -keep class android.support.annotation.Keep -keep @android.support.annotation.Keep class * {*;} -keepclasseswithmembers class * { @android.support.annotation.Keep ; } -keepclasseswithmembers class * { @android.support.annotation.Keep ; } -keepclasseswithmembers class * { @android.support.annotation.Keep (...); } #第三方jar包不被混淆 -keep class com.github.** {*;} "},"第2章_GIT常用方法/1_gitreset三种模式.html":{"url":"第2章_GIT常用方法/1_gitreset三种模式.html","title":"1_gitreset三种模式","keywords":"","body":"Git Reset 三种模式 https://www.jianshu.com/p/c2ec5f06cf1a ‌ 有时候，我们用Git的时候有可能commit提交代码后，发现这一次commit的内容是有错误的，那么有两种处理方法： 1、修改错误内容，再次commit一次 2、使用git reset 命令撤销这一次错误的commit 第一种方法比较直接，但会多次一次commit记录。 而我个人更倾向第二种方法，错误的commit没必要保留下来。 那么今天来说一下git reset。它的一句话概括 git-reset - Reset current HEAD to the specified state ‌ 意思就是可以让HEAD这个指针指向其他的地方。例如我们有一次commit不是不是很满意，需要回到上一次的Commit里面。那么这个时候就需要通过reset，把HEAD指针指向上一次的commit的点。 它有三种模式，soft,mixed,hard，具体的使用方法下面这张图，展示的很全面了。 git各个区域和命令关系 ‌ 这三个模式理解了，对于使用这个命令很有帮助。在理解这三个模式之前，需要略微知道一点Git的基本流程。正如上图，Git会有三个区域： ‌ Working Tree 当前的工作区域 Index/Stage 暂存区域，和git stash命令暂存的地方不一样。使用git add xx，就可以将xx添加近Stage里面 Repository 提交的历史，即使用git commit提交后的结果 ‌ 文件存入Repository流程 ‌ 以下简单敘述一下把文件存入Repository流程： ‌ 刚开始 working tree 、 index 与 repository(HEAD)里面的內容都是一致的 阶段1 当git管理的文件夹里面的内容出现改变后，此時 working tree 的內容就会跟 index 及 repository(HEAD)的不一致，而Git知道是哪些文件(Tracked File)被改动过，直接将文件状态设置为 modified (Unstaged files)。 阶段2 当我們执行 git add 后，会将这些改变的文件內容加入 index 中 (Staged files)，所以此时working tree跟index的內容是一致的，但他们与repository(HEAD)內容不一致。 阶段3 接着执行 git commit 後，將Git索引中所有改变的文件內容提交至 Repository 中，建立出新的 commit 节点(HEAD)后， working tree 、 index 與与repository(HEAD)区域的内容 又会保持一致。 阶段4 ‌ 实战演示 ‌ reset --hard：重置stage区和工作目录: ‌ reset --hard 会在重置 HEAD 和branch的同时，重置stage区和工作目录里的内容。当你在 reset 后面加了 --hard 参数时，你的stage区和工作目录里的内容会被完全重置为和HEAD的新位置相同的内容。换句话说，就是你的没有commit的修改会被全部擦掉。 ‌ 例如你在上次 commit 之后又对文件做了一些改动：把修改后的ganmes.txt文件add到stage区，修改后的shopping list.txt保留在工作目录 git status ‌ 最初状态 然后，你执行了reset并附上了--hard参数： git reset --hard HEAD^ ‌ 你的 HEAD 和当前 branch 切到上一条commit 的同时，你工作目录里的新改动和已经add到stage区的新改动也一起全都消失了： git status ‌ reset --hard head^之后 可以看到，在 reset --hard 后，所有的改动都被擦掉了。 ‌ reset --soft：保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区 ‌ reset --soft 会在重置 HEAD 和 branch 时，保留工作目录和暂存区中的内容，并把重置 HEAD 所带来的新的差异放进暂存区。 ‌ 什么是「重置 HEAD 所带来的新的差异」？就是这里： ‌ 由于 HEAD 从 4 移动到了 3，而且在 reset 的过程中工作目录和暂存区的内容没有被清理掉，所以 4 中的改动在 reset 后就也成了工作目录新增的「工作目录和 HEAD 的差异」。这就是上面一段中所说的「重置 HEAD 所带来的差异」。 ‌ 此模式下会保留 working tree工作目录的內容，不会改变到目前所有的git管理的文件夹的內容；也会 保留 index暂存区的內容，让 index 暂存区与 working tree 工作目录的內容是一致的。就只有 repository 中的內容的更变需要与 reset 目标节点一致，因此原始节点与reset节点之间的差异变更集合会存在与index暂存区中(Staged files)，所以我们可以直接执行 git commit 將 index暂存区中的內容提交至 repository 中。当我们想合并「当前节点」与「reset目标节点」之间不具太大意义的 commit 记录(可能是阶段性地频繁提交)時，可以考虑使用 Soft Reset 来让 commit 演进线图较为清晰点。 ‌ 所以在同样的情况下，还是老样子：把修改后的ganmes.txt文件add到stage区，修改后的shopping list.txt保留在工作目录 git status ‌ 最初状态 假设此时当前 commit 的改动内容是新增了 laughters.txt 文件： git show --stat ‌ git show --stat ‌ 如果这时你执行： git reset --soft HEAD^ ‌ 那么除了 HEAD 和它所指向的 branch1 被移动到 HEAD^ 之外，原先 HEAD 处 commit 的改动（也就是那个 laughters.txt 文件）也会被放进暂存区： git status ‌ 使用git reset --soft HEAD^后 这就是--soft 和 --hard 的区别：--hard 会清空工作目录和暂存区的改动,而 *--soft则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。 ‌ reset 不加参数(mixed)：保留工作目录，并清空暂存区 ‌ reset 如果不加参数，那么默认使用 --mixed 参数。它的行为是：保留工作目录，并且清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（mixed）放在工作目录中」。 ‌ 还以同样的情况为例： git status ‌ 最初状态 ‌ 修改了 的games.txt 和 shopping list.txt，并把 games.txt 放进了暂存区。 git show --stat ‌ git show --stat ‌ 最新的 commit 中新增了 laughters.txt 文件。 ‌ 这时如果你执行无参数的reset或者带--mixed参数： git reset HEAD^ git reset --mixed HEAD^ ‌ 工作目录的内容和 --soft 一样会被保留，但和 --soft 的区别在于，它会把暂存区清空,并把原节点和reset节点的差异的文件放在工作目录，总而言之就是，工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录 git status ‌ git reset HEAD^之后 ‌ 总结 ‌ reset 的本质：移动 HEAD 以及它所指向的 branch ‌ 实质上，reset 这个指令虽然可以用来撤销 commit ，但它的实质行为并不是撤销，而是移动 HEAD ，并且「捎带」上 HEAD 所指向的 branch（如果有的话）。也就是说，reset 这个指令的行为其实和它的字面意思 \"reset\"（重置）十分相符：它是用来重置 HEAD 以及它所指向的 branch 的位置的。 ‌ 而 reset --hard HEAD^ 之所以起到了撤销 commit 的效果，是因为它把 HEAD 和它所指向的 branch 一起移动到了当前 commit 的父 commit 上，从而起到了「撤销」的效果： ‌ git reset ‌ Git 的历史只能往回看，不能向未来看，所以把 HEAD 和 branch 往回移动，就能起到撤回 commit 的效果。 ‌ 所以同理，reset --hard 不仅可以撤销提交，还可以用来把 HEAD 和 branch 移动到其他的任何地方。 git reset --hard branch2 ‌ git reset --hard branch2 ‌ reset三种模式区别和使用场景 ‌ 区别： ‌ --hard：重置位置的同时，直接将 working Tree工作目录、 index 暂存区及 repository 都重置成目标Reset节点的內容,所以效果看起来等同于清空暂存区和工作区。 --soft：重置位置的同时，保留working Tree工作目录和index暂存区的内容，只让repository中的内容和 reset 目标节点保持一致，因此原节点和reset节点之间的【差异变更集】会放入index暂存区中(Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和Reset节点之间的所有差异都会放到暂存区中。 --mixed（默认）：重置位置的同时，只保留Working Tree工作目录的內容，但会将 Index暂存区 和 Repository 中的內容更改和reset目标节点一致，因此原节点和Reset节点之间的【差异变更集】会放入Working Tree工作目录中。所以效果看起来就是原节点和Reset节点之间的所有差异都会放到工作目录中。 ‌ 使用场景: ‌ --hard：(1) 要放弃目前本地的所有改变時，即去掉所有add到暂存区的文件和工作区的文件，可以执行 git reset -hard HEAD 来强制恢复git管理的文件夹的內容及状态；(2) 真的想抛弃目标节点后的所有commit（可能觉得目标节点到原节点之间的commit提交都是错了，之前所有的commit有问题）。 --soft：原节点和reset节点之间的【差异变更集】会放入index暂存区中(Staged files)，所以假如我们之前工作目录没有改过任何文件，也没add到暂存区，那么使用reset --soft后，我们可以直接执行 git commit 將 index暂存区中的內容提交至 repository 中。为什么要这样呢？这样做的使用场景是：假如我们想合并「当前节点」与「reset目标节点」之间不具太大意义的 commit 记录(可能是阶段性地频繁提交,就是开发一个功能的时候，改或者增加一个文件的时候就commit，这样做导致一个完整的功能可能会好多个commit点，这时假如你需要把这些commit整合成一个commit的时候)時，可以考虑使用reset --soft来让 commit 演进线图较为清晰。总而言之，可以使用--soft合并commit节点。 --mixed（默认）：(1)使用完reset --mixed后，我們可以直接执行 git add 将這些改变果的文件內容加入 index 暂存区中，再执行 git commit 将 Index暂存区 中的內容提交至Repository中，这样一样可以达到合并commit节点的效果（与上面--soft合并commit节点差不多，只是多了git add添加到暂存区的操作）；(2)移除所有Index暂存区中准备要提交的文件(Staged files)，我们可以执行 git reset HEAD 来 Unstage 所有已列入 Index暂存区 的待提交的文件。(有时候发现add错文件到暂存区，就可以使用命令)。(3)commit提交某些错误代码，或者没有必要的文件也被commit上去，不想再修改错误再commit（因为会留下一个错误commit点），可以回退到正确的commit点上，然后所有原节点和reset节点之间差异会返回工作目录，假如有个没必要的文件的话就可以直接删除了，再commit上去就OK了。 ‌ 假如手贱，又想回退撤销的版本呢? ‌ 请看另外一篇文章:TODO ‌ 参考文章： ‌ https://dotblogs.com.tw/wasichris/2016/04/29/225157 https://www.domon.cn/2018/09/06/Git-reset-used-in-coding/ https://juejin.im/book/5a124b29f265da431d3c472e/section/5a14529bf265da43310d7351(掘金小册) "},"第2章_GIT常用方法/2_git撤销回滚操作.html":{"url":"第2章_GIT常用方法/2_git撤销回滚操作.html","title":"2_git撤销回滚操作","keywords":"","body":"Git撤销&回滚操作(git reset 和 get revert) https://blog.csdn.net/asoar/article/details/84111841 ‌ git的工作流 ‌ 工作区：即自己当前分支所修改的代码，git add xx 之前的！不包括 git add xx 和 git commit xxx 之后的。 ‌ 暂存区：已经 git add xxx 进去，且未 git commit xxx 的。 ‌ 本地分支：已经git commit -m xxx 提交到本地分支的。 这里写图片描述 ‌ 代码回滚 ‌ 在上传代码到远程仓库的时候，不免会出现问题，任何过程都有可能要回滚代码： ‌ 1、在工作区的代码 git checkout -- a.txt # 丢弃某个文件，或者 git checkout -- . # 丢弃全部 // 删除当前目录下所有没有 track 过的文件 // 不会删除 .gitignore 文件里面指定的文件夹和文件, 不管这些文件有没有被 track 过 git clean -f git clean -df #返回到某个节点，（未跟踪文件的删除） git clean 参数 -n 不实际删除，只是进行演练，展示将要进行的操作，有哪些文件将要被删除。（可先使用该命令参数，然后再决定是否执行） -f 删除文件 -i 显示将要删除的文件 -d 递归删除目录及文件（未跟踪的） -q 仅显示错误，成功删除的文件不显示 ‌ 注意：git checkout – . 丢弃全部，也包括：新增的文件会被删除、删除的文件会恢复回来、修改的文件会回去。这几个前提都说的是，回到暂存区之前的样子。对之前保存在暂存区里的代码不会有任何影响。对commit提交到本地分支的代码就更没影响了。当然，如果你之前压根都没有暂存或commit，那就是回到你上次pull下来的样子了。 ‌ 2、代码git add到缓存区，并未commit提交 git reset HEAD . 或者 git reset HEAD a.txt ‌ 这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化 ‌ 3、git commit到本地分支、但没有git push到远程 ‌ git log # 得到你需要回退一次提交的commit id git reset --hard # 回到其中你想要的某个版 或者 git reset --hard HEAD^ # 回到最新的一次提交 或者 git reset HEAD^ # 此时代码保留，回到 git add 之前 ‌ 4、git push把修改提交到远程仓库 1）通过git reset是直接删除指定的commit ‌ git log # 得到你需要回退一次提交的commit id git reset --hard git push origin HEAD --force # 强制提交一次，之前错误的提交就从远程仓库删除 ‌ 2）通过git revert是用一次新的commit来回滚之前的commit ‌ git log # 得到你需要回退一次提交的commit id git revert # 撤销指定的版本，撤销也会作为一次提交进行保存 ‌ 3） git revert 和 git reset的区别 - git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留； - git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除 ‌ 开发过程中，你肯定会遇到这样的场景： ‌ 场景一： 糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！ ‌ 场景二： 彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！ ‌ 场景三： 刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！ ‌ 撤销 ‌ 上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！ ‌ 情况一：文件被修改了，但未执行**git add**操作(working tree内撤销) git checkout fileName git checkout . ‌ 情况二：同时对多个文件执行了**git add**操作，但本次只想提交其中一部分文件 $ git add * $ git status # 取消暂存 $ git reset HEAD ‌ 情况三：文件执行了**git add**操作，但想撤销对其的修改（index内回滚） # 取消暂存 git reset HEAD fileName # 撤销修改 git checkout fileName ‌ 情况四：修改的文件已被**git commit**，但想再次修改不再产生新的Commit # 修改最后一次提交 $ git add sample.txt $ git commit --amend -m\"说明\" ‌ 情况五：已在本地进行了多次**git commit**操作，现在想撤销到其中某次Commit git reset [--hard|soft|mixed|merge|keep] [commit|HEAD] ‌ 具体参数和使用说明，请查看：Git Pro深入浅出（二）中的重置揭秘部分 ‌ 回滚 ‌ 上述场景二，已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ ‌ 如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二\\的情况 git checkout ‌ 如果你回到当前HEAD指向 git checkout ‌ 情况一：撤销指定文件到指定版本 # 查看指定文件的历史版本 git log # 回滚到指定commitID git checkout ‌ 情况二：删除最后一次远程提交 ‌ 方式一：使用revert git revert HEAD git push origin master ‌ 方式二：使用reset git reset --hard HEAD^ git push origin master -f ‌ 二者区别： ‌ revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在； reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。 ‌ 情况三：回滚某次提交 # 找到要回滚的commitID git log git revert commitID ‌ 删除某次提交 git log --oneline -n5 git rebase -i \"commit id\"^ ‌ 注意：需要注意最后的^号，意思是commit id的前一次提交 git rebase -i \"5b3ba7a\"^ ‌ 在编辑框中删除相关commit，如pick 5b3ba7a test2，然后保存退出（如果遇到冲突需要先解决冲突）！ git push origin master -f ‌ 通过上述操作，如果你想对历史多个commit进行处理或者，可以选择**git rebase -i**，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit。 "},"第2章_GIT常用方法/3_HEAD和HEAD^的作用和区别.html":{"url":"第2章_GIT常用方法/3_HEAD和HEAD^的作用和区别.html","title":"3_HEAD和HEAD^的作用和区别","keywords":"","body":"git在回退版本时HEAD~和HEAD^的作用和区别 https://blog.csdn.net/albertsh/article/details/106448035 ‌ 前言 ‌ 今天总结一个小知识点，虽然不难，但是对新手有很强的迷惑性，了解一下也挺好。我们在使用 Git 回退到版本的时候，可能见过这种写法 git reset --hard HEAD~，有时候也会遇到这种写法 git reset --hard HEAD^，这两个语句都是将代码库还原到上一个版本，但是只差了一个符号，他们究竟有什么区别呢？这里先给出结论：HEAD~ 和 HEAD^ 含义不同，功能一样！ ‌ HEAD ‌ HEAD 这个词在 git 使用过程中经常出现，作用很像是数据结构中指向二叉树根节点root的指针。有个 root 指针我们就可以对二叉树进行任意操作，它是二叉树的根基。而 git 中的 HEAD 概念也类似一个指针，它指向是当前分支的“头”，通过这个头节点可以追寻到当前分支之前的所有提交记录。 ‌ git 的提交记录之间的关系很像一棵树，或者说是一张图，通过当前的提交记录指向上一次提交记录串联起来，形成一个头结构，而在 git 中我们常常说的切换分支，只不过是 git 客户端帮你把要操作的那条路径的头节点，存储到了 HEAD 文件中。 ‌ HEAD 在 git 版本控制中代表头节点，也就是分支的最后一次提交，同时也是一个文件，通常在版本库中 repository/.git/HEAD，其中保存的一般是 ref: refs/heads/master 这种分支的名字，而本质上就是指向一次提交的 hash 值，一般长成这个样子 ce11d9be5cc7007995b607fb12285a43cd03154b。 ‌ HEAD~ 和 HEAD^ ‌ 在 HEAD 后面加 ^ 或者 ~ 其实就是以 HEAD 为基准，来表示之前的版本，因为 HEAD 被认为是当前分支的最新版本，那么 HEAD~ 和 HEAD^ 都是指次新版本，也就是倒数第二个版本，HEAD~~ 和 HEAD^^ 都是指次次新版本，也就是倒数第三个版本，以此类推。 ‌ 这个说法在之前的总结 《git checkout/git reset/git revert/git restore常用回退操作》 中提到过，但是并未展开说，今天就来测试一下。 ‌ HEAD 后面 ~ 和 ^ 的区别 ‌ 其实 HEAD~ 和 HEAD^ 的作用是相同的，这两者的区别出现在重复使用或者加数字的情况，下面来分情况说明一下。 ‌ HEAD~ 和 HEAD^后面都加1 ‌ 加上参数1之后变成了 HEAD~1 和 HEAD^1，其实这就是他们本来的面貌，在参数为 1 的情况下可以省略，HEAD~1 表示回退一步，参数1表示后退的步数，默认推到第一个父提交上，而HEAD^1表示后退一步，直接后退到第n个父提交上，数字1表示是第一个父提交。 ‌ 这里引入一个父提交的概念，也就是在最新提交之前的最近的提交我称它为父提交，但是父提交会有两个吗？实际上会的，直接的父提交可能会有很多，分支合并是产生父提交的一种常见原因，两个分支合并到一起时，这两个分支的原 HEAD 都会成为合并后最新提交的父提交。 ‌ 理解了这个概念，我们发现虽然数字是一样的，但是含义却不相同，HEAD~1 中指的是后退的步数，HEAD^1指的是退到第几个父提交上。 ‌ HEAD~ 和 HEAD^后面都加0 ‌ 这是一种比较特殊的情况， 加上参数0之后变成了 HEAD~0 和 HEAD^0，其实他们指向的节点没有改变，还是代表了 HEAD，只要了解这种情况就行了，我还没有见过谁这样写过。 ‌ HEAD~ 和 HEAD^后面都加大于1的数字 ‌ 这时就会发现两者的不同了，比如我们把数字都定为2，那么 HEAD~2 代表后退两步，每一步都后退到第一个父提交上，而 HEAD^2 代表后退一步，这一步退到第二个父提交上，如果没有第二个父提交就会报出以下错误： fatal: ambiguous argument ‘HEAD^2’: unknown revision or path not in the working tree. Use ‘–’ to separate paths from revisions, like this: ‘git […] – […]’ ‌ 具体示例 ‌ 上面说了几种加数字的情况，如果是第一次接触可能还是不太明白，没关系，我可以实际操作一下，看个具体的例子就明白了。 ‌ 准备工作 ‌ 下面是一个测试代码库的分支结构，一共有 dev1、dev2、dev3、dev4 四个分支，最终合并到 dev1 分支，提交记录如下： albert@home-pc MINGW64 /d/gitstart (dev1) $ git alllog * ce11d9b (HEAD -> dev1) Merge branch 'dev3' into dev1 |\\ | * e330eac (dev3) update at dev3 - 3 | * 7ab3c98 Merge branch 'dev4' into dev3 | |\\ | | * c8795e8 (dev4) update at dev4 - 2 | | * 155d3db update at dev4 - 1 | * | ccdf16a update at dev3 - 2 | * | 9f08bb0 update at dev3 - 1 | |/ * | f82b57b update at dev1 - 3 * | dcdcb87 Merge branch 'dev2' into dev1 |\\ \\ | * | 32d6213 (dev2) update at dev2 - 2 | * | ca4db4a update at dev2 - 1 | |/ | * d8d80b7 update readme at dev2 * | 034ccb6 update readme at dev1 - 2 * | d58fedc update readme at dev1 - 1 ‌ 也许有颜色标记会看得更清楚一些，所以截个图放在这： git_branch_head ‌ 刚看这种图的时候要注意一点，记录列表中的先后关系不代表提交时间的先后，如果习惯于看SVN的记录以后，很容易在看日志信息时加上时间因素，但是这个时间因素在 git 查看记录时变得不再明显，比如上面记录中的 e330eac 在图形上要比 f82b57b 更接近 HEAD 提交 ce11d9b，但是因为处在不同的分支上，在合并之前他俩的修改时间还真不一定是哪个更早一些。 ‌ 树形记录 ‌ 在 git 的提交记录图上，我们可以确定当前提交的父提交（所依赖的提交）是哪一个或者哪几个，但是不能确定任意两个提交的时间先后，为了能更清楚的看清分支提交的依赖关系，还是看下面这个树形图更方便一些。 ‌ ‌ 查看命令 ‌ 在验证 HEAD~ 和 HEAD^ 之前我们先学习一个命令 git rev-parse HEAD 这个命令可以显示出 HEAD 对应的提交的 hash 值，加上 --short 参数就可以显示出长度为7位的短 hash，用起来比较方便，测试如下： albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse HEAD ce11d9be5cc7007995b607fb12285a43cd03154b albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD ce11d9b ‌ 开始测试 ‌ 下面可以用 git rev-parse --short 命令来测试 HEAD 后面跟不同参数时对应的提交是哪一个了，测试如下： ‌ HEAD~、HEAD^、HEAD~1、HEAD^1 albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD~ f82b57b albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD^ f82b57b albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD~1 f82b57b albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD^1 f82b57b ‌ 测试后发现，这四种写法结果是一样的，都是指向 HEAD 的第一个父提交，这和我们前面说的观点一致。 ‌ HEAD~~、HEAD^^、HEAD~2、HEAD^2 albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD~~ dcdcb87 albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD^^ dcdcb87 albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD~2 dcdcb87 albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD^2 e330eac ‌ 这次我们发现，前三个表示方法是一样的，指向同一个提交记录，但是最后一个与他们不同，这时根据前面提到定义来看就行了，HEAD~~ 实际上是 HEAD~1~1的简写，而~ 后的数字就是指的后退的步数，所以 HEAD~~ 等价于 HEAD~2，属于一种合并计算。 ‌ HEAD^^ 是 HEAD^1^1 的简写，而 ^ 后面的数字表示后退一步到第几个父提交上，因为数字是1，所以 HEAD^^ 表示退一步到第一个父提交上，在退一步到第一个父提交上，这时与 HEAD~~ 的作用是相同的。 ‌ HEAD^2 就有些不同了，它表示后退一步到第二个父提交上，所以对照树形图是第二排的第二个节点。 ‌ ~ 和 ^ 混合使用 ‌ 看了上面的例子对于 ~ 和 ^ 的使用应该有些明白了，它俩其实可以组合使用的，比如想退到第5排、第2个节点上，也就是 ca4db4a 上，简单来看需要第一步到第一个父提交上，在退一步到第一个父提交上，然后退一步到第二个父提交上，最后退一步到第一个父提交上。 ‌ 那么我们根据需求可以写成 HEAD^1^1^2^1，测试一下看看 hash 是否正确： albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD^1^1^2^1 ca4db4a ‌ 测试发现没有问题，其实还可以合并啊，我们知道1是可以省略的，所以可以简写成 HEAD^^^2^，另外多个 ^ 还可以写成 ~n 的形式，所以这个节点还可以表示成 HEAD~2^2^的样子，测试如下，结果是一样的。 albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD^^^2^ ca4db4a albert@home-pc MINGW64 /d/gitstart (dev1) $ git rev-parse --short HEAD~2^2^ ca4db4a ‌ 关于 git reset 的一点思考 ‌ 刚学习 git reset 的命令时一直认为是一个回退命令，其实学习一段时间之后发现，这个命令其实很符合它的名字，就是一个重置(reset)命令，通过 git reset 命令可以修改 HEAD 指向不同的提交，这个提交甚至都不必是当前分支上的某次提交，测试后发现，只要是版本库中合法提交都可以使用这个命令进行设置，相应的版本库的内容也会发生对应的变化，从这一点来看，它真的太强大了，它可以使你正在开发的 dev 分支瞬间变成 master 分支。 ‌ 总结 ‌ HEAD~ 后面加数字表示后退的步数，每次后退都默认退到第一个父提交上，HEAD~2 表示连退两步。 HEAD^ 后面加数字表示只退一步，但是这一步后退到数字表示的父提交上，HEAD^2 表示退一步到第二个父提交上。 git 在查看多分支提交记录时，日志的先后顺序不代表提交时间的先后顺序。 git reset 命令是一个重置 HEAD 的命令，可以指挥版本库指向任何一个合法提交。 "},"第2章_GIT常用方法/4_Git_Tag相关操作.html":{"url":"第2章_GIT常用方法/4_Git_Tag相关操作.html","title":"4_Git_Tag相关操作","keywords":"","body":"Git打Tag相关操作 https://www.jianshu.com/p/dab7da2a0721 ‌ 项目的版本管理中,每当一个release版本发布时,需要做一个记录,以便以后需要的时候重新打包这个版本,这时候就用到tag这个功能. ‌ 更详细内容 ‌ 打标签 git tag -a 0.1.3 -m “Release version 0.1.3″ ‌ 详解： git tag 是命令 -a 0.1.3是增加 名为0.1.3的标签 -m 后面跟着的是标签的注释 ‌ 打标签的操作发生在我们commit修改到本地仓库之后。 ‌ 相关操作 ‌ 提交 git add . git commit -m “fixed some bugs” git tag -a 0.1.3 -m “Release version 0.1.3″ ‌ 分享提交标签到远程服务器上 git push origin master git push origin --tags ‌ –tags参数表示提交所有tag至服务器端，普通的git push origin master操作不会推送标签到服务器端。 ‌ 切换到已有Tag git tag --list // 查看已有tag列表 git checkout [tag/branch/commit] // 切换到指定tag/branch/commit都是此命令 ‌ 删除标签的命令 git tag -d 0.1.3 ‌ 删除远端服务器的标签 git push origin :refs/tags/0.1.3 "},"第3章_设计模式/1_android_MVP模式详解.html":{"url":"第3章_设计模式/1_android_MVP模式详解.html","title":"1_android_MVP模式详解","keywords":"","body":"Android MVP模式详解 https://www.cnblogs.com/lixiansheng/p/11382389.html ‌ 一、MVP概述 ‌ MVP，全称 Model-View-Presenter，即模型-视图-层现器。 ‌ 提到MVP，就必须要先介绍一下它的前辈MVC，因为MVP正是基于MVC的基础发展而来的。两个之间的关系也是源远流长。 ‌ MVC，全称Model-View-Controller，即模型-视图-控制器。 ‌ View：对应于布局文件 ‌ Model：业务逻辑和实体模型 ‌ Controllor：对应于Activity ‌ 但是View对应于布局文件，其实能做的事情特别少，实际上关于该布局文件中的数据绑定的操作，事件处理的代码都在Activity中，造成了Activity既像View又像Controller，使得Activity变得臃肿。 ‌ 而当将架构改为MVP以后，Presenter的出现，将Actvity视为View层，Presenter负责完成View层与Model层的交互。现在是这样的： ‌ View 对应于Activity，负责View的绘制以及与用户交互 ‌ Model 依然是业务逻辑和实体模型 ‌ Presenter 负责完成View于Model间的交互 ‌ 下面两幅图通过数据与视图之间的交互清楚地展示了这种变化： ‌ MVC模式下实际上就是Activty与Model之间交互，View完全独立出来了。 ‌ MVP模式通过Presenter实现数据和视图之间的交互，简化了Activity的职责。同时即避免了View和Model的直接联系，又通过Presenter实现两者之间的沟通。 ‌ 总结：MVP模式减少了Activity的职责，简化了Activity中的代码，将复杂的逻辑代码提取到了Presenter中进行处理，模块职责划分明显，层次清晰。与之对应的好处就是，耦合度更低，更方便的进行测试。 ‌ MVC和MVP的区别 ‌ MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的。 ‌ 还有一点注意：MVC中V对应的是布局文件，MVP中V对应的是Activity。 ‌ 二、MVP的简单使用 ‌ 大多数MVP模式的示例都使用登录案例进行介绍。因为简单方便，同时能提现出MVP的特点。今天我们也以此例进行学习。 使用MVP的好处之一就是模块职责划分明显，层次清晰。 该例的结构图即可展现此优点。 ‌ 1.Model层 ‌ 在本例中，M0del层负责对从登录页面获取地帐号密码进行验证（一般需要请求服务器进行验证，本例直接模拟这一过程）。 从上图的包结构图中可以看出，Model层包含内容： ‌ ①实体类bean ‌ ②接口，表示Model层所要执行的业务逻辑 ‌ ③接口实现类，具体实现业务逻辑，包含的一些主要方法 ‌ 下面以代码的形式一一展开。 ‌ ①实体类bean public class User { private String password; private String username; public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } @Override public String toString() { return \"User{\" + \"password='\" + password + '\\'' + \", username='\" + username + '\\'' + '}'; } ‌ 封装了用户名、密码，方便数据传递。 ‌ ②接口 public interface LoginModel { void login(User user, OnLoginFinishedListener listener); } ‌ 其中OnLoginFinishedListener 是presenter层的接口，方便实现回调presenter，通知presenter业务逻辑的返回结果，具体在presenter层介绍。 ‌ ③接口实现类 public class LoginModelImpl implements LoginModel { @Override public void login(User user, final OnLoginFinishedListener listener) { final String username = user.getUsername(); final String password = user.getPassword(); new Handler().postDelayed(new Runnable() { @Override public void run() { boolean error = false; if (TextUtils.isEmpty(username)){ listener.onUsernameError();//model层里面回调listener error = true; } if (TextUtils.isEmpty(password)){ listener.onPasswordError(); error = true; } if (!error){ listener.onSuccess(); } } }, 2000); } ‌ 实现Model层逻辑：延时模拟登陆（2s），如果用户名或者密码为空则登陆失败，否则登陆成功。 ‌ 2.View层 ‌ 视图：将Modle层请求的数据呈现给用户。一般的视图都只是包含用户界面(UI)，而不包含界面逻辑，界面逻辑由Presenter来实现。 ‌ 从上图的包结构图中可以看出，View包含内容： ‌ ①接口，上面我们说过Presenter与View交互是通过接口。其中接口中方法的定义是根据Activity用户交互需要展示的控件确定的。 ‌ ②接口实现类，将上述定义的接口中的方法在Activity中对应实现具体操作。 ‌ 下面以代码的形式一一展开。 ‌ ①接口 public interface LoginView { //login是个耗时操作，我们需要给用户一个友好的提示，一般就是操作ProgressBar void showProgress(); void hideProgress(); //login当然存在登录成功与失败的处理，失败给出提示 void setUsernameError(); void setPasswordError(); //login成功，也给个提示 void showSuccess(); ‌ 上述5个方法都是presenter根据model层返回结果需要view执行的对应的操作。 ‌ ②接口实现类 ‌ 即对应的登录的Activity，需要实现LoginView接口。 public class LoginActivity extends AppCompatActivity implements LoginView, View.OnClickListener { private ProgressBar progressBar; private EditText username; private EditText password; private LoginPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); progressBar = (ProgressBar) findViewById(R.id.progress); username = (EditText) findViewById(R.id.username); password = (EditText) findViewById(R.id.password); findViewById(R.id.button).setOnClickListener(this); //创建一个presenter对象，当点击登录按钮时，让presenter去调用model层的login()方法，验证帐号密码 presenter = new LoginPresenterImpl(this); } @Override protected void onDestroy() { presenter.onDestroy(); super.onDestroy(); } @Override public void showProgress() { progressBar.setVisibility(View.VISIBLE); } @Override public void hideProgress() { progressBar.setVisibility(View.GONE); } @Override public void setUsernameError() { username.setError(getString(R.string.username_error)); } @Override public void setPasswordError() { password.setError(getString(R.string.password_error)); } @Override public void showSuccess() { progressBar.setVisibility(View.GONE); Toast.makeText(this,\"login success\",Toast.LENGTH_SHORT).show(); } @Override public void onClick(View v) { User user = new User(); user.setPassword(password.getText().toString()); user.setUsername(username.getText().toString()); presenter.validateCredentials(user); } ‌ View层实现Presenter层需要调用的控件操作，方便Presenter层根据Model层返回的结果进行操作View层进行对应的显示。 ‌ 3.Presenter层 ‌ Presenter是用作Model和View之间交互的桥梁。 从上图的包结构图中可以看出，Presenter包含内容： ‌ ①接口，包含Presenter需要进行Model和View之间交互逻辑的接口，以及上面提到的Model层数据请求完成后回调的接口。 ‌ ②接口实现类，即实现具体的Presenter类逻辑。 ‌ 下面以代码的形式一一展开。 ‌ ①接口 public interface OnLoginFinishedListener { void onUsernameError(); void onPasswordError(); void onSuccess(); ‌ 当Model层得到请求的结果，需要回调Presenter层，让Presenter层调用View层的接口方法。 public interface LoginPresenter { void validateCredentials(User user); void onDestroy(); } ‌ 登陆的Presenter 的接口，实现类为LoginPresenterImpl，完成登陆的验证，以及销毁当前view。 ‌ ②接口实现类 public class LoginPresenterImpl implements LoginPresenter, OnLoginFinishedListener { private LoginView loginView; private LoginModel loginModel; public LoginPresenterImpl(LoginView loginView) { this.loginView = loginView; this.loginModel = new LoginModelImpl(); } @Override public void validateCredentials(User user) { if (loginView != null) { loginView.showProgress(); } loginModel.login(user, this); } @Override public void onDestroy() { loginView = null; } @Override public void onUsernameError() { if (loginView != null) { loginView.setUsernameError(); loginView.hideProgress(); } } @Override public void onPasswordError() { if (loginView != null) { loginView.setPasswordError(); loginView.hideProgress(); } } @Override public void onSuccess() { if (loginView != null) { loginView.showSuccess(); } } ‌ 由于presenter完成二者的交互，那么肯定需要二者的实现类（通过传入参数，或者new）。 ‌ presenter里面有个OnLoginFinishedListener， 其在Presenter层实现，给Model层回调，更改View层的状态， 确保 Model层不直接操作View层。 ‌ 示例展示： ‌ 代码地址 ‌ 三、总结 ‌ MVP模式的整个核心流程： ‌ View与Model并不直接交互，而是使用Presenter作为View与Model之间的桥梁。其中Presenter中同时持有View层的Interface的引用以及Model层的引用，而View层持有Presenter层引用。当View层某个界面需要展示某些数据的时候，首先会调用Presenter层的引用，然后Presenter层会调用Model层请求数据，当Model层数据加载成功之后会调用Presenter层的回调方法通知Presenter层数据加载情况，最后Presenter层再调用View层的接口将加载后的数据展示给用户。 "},"第4章_AndroidUI/第1节_Fragment/1_FragmentPagerAdapter和FragmentStatePagerAdapter区别.html":{"url":"第4章_AndroidUI/第1节_Fragment/1_FragmentPagerAdapter和FragmentStatePagerAdapter区别.html","title":"1_FragmentPagerAdapter和FragmentStatePagerAdapter区别","keywords":"","body":"FragmentPagerAdapter和FragmentStatePagerAdapter区别 简单介绍 FragmentPagerAdapter 是另外一种可用的 PagerAdapter ，其用法与 FragmentState-PagerAdapter 基本一致。 唯一的区别在于：卸载不再需要的fragment时，各自采用的处理方法有所不同。 FragmentStatePagerAdapter 会销毁不需要的fragment。事务提交后，activity的 Fragment-Manager 中的fragment会被彻底移除。 FragmentStatePagerAdapter 类名中的“state”表明：在销毁fragment时，可在 onSaveInstanceState(Bundle) 方法中保存fragment的 Bundle 信息。 用户切换回来时，保存的实例状态可用来恢复生成新的fragment（如图11-4所示）。 相比之下， FragmentPagerAdapter 有不同的做法。对于不再需要的fragment， Fragment- PagerAdapter 会选择调用事务的 detach(Fragment) 方法来处理它，而非 remove(Fragment) 方法。 也就是说， FragmentPagerAdapter 只是销毁了fragment的视图，fragment实例还保留在FragmentManager 中。 因此， FragmentPagerAdapter 创建的fragment永远不会被销毁（如图11-5所示）。 下面我们来比较一下两者在加载和销毁fragment item时都做了什么： FragmentPagerAdapter源码： @Override public Object instantiateItem(ViewGroup container, int position) { if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } final long itemId = getItemId(position); // Do we already have this fragment? String name = makeFragmentName(container.getId(), itemId); Fragment fragment = mFragmentManager.findFragmentByTag(name); if (fragment != null) { if (DEBUG) Log.v(TAG, \"Attaching item #\" + itemId + \": f=\" + fragment); mCurTransaction.attach(fragment); } else { fragment = getItem(position); if (DEBUG) Log.v(TAG, \"Adding item #\" + itemId + \": f=\" + fragment); mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); } if (fragment != mCurrentPrimaryItem) { fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); } return fragment; } 在instantiateItem方法中，主要是将Fragment添加到FragmentManager中。未添加到FragmentManager中的执行add操作，已添加到FragmentManager中的只进行attach操作。 @Override public void destroyItem(ViewGroup container, int position, Object object) { if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } if (DEBUG) Log.v(TAG, \"Detaching item #\" + getItemId(position) + \": f=\" + object + \" v=\" + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object); } 在destroyItem方法中，只是进行detach操作。detach操作并不会将Fragment销毁，Fragment依旧是由FragmentManager进行管理。 FragmentStatePagerAdapter源码： @Override public Object instantiateItem(ViewGroup container, int position) { if (mFragments.size() > position) { Fragment f = mFragments.get(position); if (f != null) { return f; } } if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } Fragment fragment = getItem(position); if (DEBUG) Log.v(TAG, \"Adding item #\" + position + \": f=\" + fragment); if (mSavedState.size() > position) { Fragment.SavedState fss = mSavedState.get(position); if (fss != null) { fragment.setInitialSavedState(fss); } } while (mFragments.size() FragmentStatePagerAdapter是通过一个mFragments数组来存储fragment的，通过mSavedState数组来存储fragment销毁时的状态，通过position获取到的fragment可能为空（被回收），如果为空，则会再次调用getItem方法重新创建新的fragment，然后将mSavedState中存储的状态重新赋予这个新的fragment， 达到fragment恢复的效果。 @Override public void destroyItem(ViewGroup container, int position, Object object) { Fragment fragment = (Fragment) object; if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } if (DEBUG) Log.v(TAG, \"Removing item #\" + position + \": f=\" + object + \" v=\" + ((Fragment)object).getView()); while (mSavedState.size() 当item在页面中不可见时，该fragment的状态会先被保存到mSavedState中，而fragment实例则会被销毁。 相同点： 两者都会保持当前item（即fragment）和前后的item的状态。 显示当前item的同时，Adapter会提前初始化后一个item，并把当前item的前一个item保存在内存中。 不同点： 在于fragment 存储、恢复、销毁 的方式不同 对滑动过去的页面是否销毁： 例如：依次从左向右有fragment1，fragment2，fragment3三个页面 FragmentPagerAdapter在滑动到fragment3时，fragment1会依次调用onPause()、onStop()、onDestroyView()，再向左滑动到fragment2时，fragment1会调用onCreateView()、onActivityCreated()、onStart()、onResume()。 结论：FragmentPagerAdapter会保留页面的状态，并不会完全销毁掉。 FragmentStatePagerAdapter在滑动到fragment3时，fragment1会依次调用onPause()、onStop()、onDestroyView()、onDestroy()、onDetach()方法，再向左滑动到fragment2时，fragment1会调用onAttach()、onCreate()、onCreateView()、onActivityCreated()、onStart()、onResume()。 结论：FragmentStatePagerAdapter会完全销毁滑动过去的item，当需要初始化的时候，会重新初始化页面。 如何选择 ① 选择哪种adapter取决于应用的要求。通常来说，使用 FragmentStatePagerAdapter 更节省内存。 如果应用需显示大量记录，每份记录最终还会包含图片。在内存中保存所有信息显然不合适，因此我们选择使用 FragmentStatePagerAdapter 。 ② 另一方面，如果用户界面只需要少量固定的fragment，则 FragmentPagerAdapter 是个安全、合适的选择。 最常见的例子为分页显示用户界面。例如，某些应用的明细视图所含内容较多，通常需分两页显示。 这时就可以将这些明细信息分拆开来，以多页面的形式展现。显然，为用户界面添加支持滑动切换的 ViewPager ， 能增强应用的触摸体验。此外，将fragment保存在内存中，更易于管理控制层的代码。 对于这种类型的用户界面，每个activity通常只有两三个fragment，基本不用担心有内存不足的风险。 notifyDataSetChanged后页面不刷新问题解决参考如下链接： https://www.cnblogs.com/lianghui66/p/3607091.html 对于 FragmentPagerAdapter 的解决方案就是，分别重载 getItem() 以及 instantiateItem() 对象。getItem() 只用于生成新的与数据无关的 Fragment；而 instantiateItem() 函数则先调用父类中的 instantiateItem() 取得所对应的 Fragment 对象，然后，根据对应的数据，调用该对象对应的方法进行数据设置。 当然，不要忘记重载 getItemPosition() 函数，返回 POSITION_NONE，这个两个类的解决方案都需要的。二者不同之处在于，FragmentStatePagerAdapter 在会在因 POSITION_NONE 触发调用的 destroyItem() 中真正的释放资源，重新建立一个新的 Fragment；而 FragmentPagerAdapter 仅仅会在 destroyItem() 中 detach 这个 Fragment，在 instantiateItem() 时会使用旧的 Fragment，并触发 attach，因此没有释放资源及重建的过程。 这样，当 notifyDataSetChanged() 被调用后，会最终触发 instantiateItem()，而不管 getItem() 是否被调用，我们都在重载的 instantiateItem() 函数中已经将所需要的数据传递给了相应的 Fragment。在 Fragment 接下来的 onCreateView(), onStart() 以及 onResume() 的事件中，它可以正确的读取新的数据，Fragment 被成功复用了。 这里需要注意一个问题，在 Fragment 没有被添加到 FragmentManager 之前，我们可以通过 Fragment.setArguments() 来设置参数，并在 Fragment 中，使用 getArguments() 来取得参数。这是常用的参数传递方式。但是这种方式对于我们说的情况不适用。因为这种数据传递方式只可能用一次，在 Fragment 被添加到 FragmentManager 后，一旦被使用，我们再次调用 setArguments() 将会导致 java.lang.IllegalStateException: Fragment already active 异常。因此，我们这里的参数传递方式选择是，在继承的 Fragment 子类中，新增几个 setter，然后通过这些 setter 将数据传递过去。反向也是类似。相关信息可以参考 [5]。哦，这些 setter 中要注意不要操作那些 View，这些 View 只有在 onCreateView() 事件后才可以操作。 针对 FragmentPagerAdapter 的解决办法如下列代码所示： @Override public Fragment getItem(int position) { MyFragment f = new MyFragment(); return f; } @Override public Object instantiateItem(ViewGroup container, int position) { MyFragment f = (MyFragment) super.instantiateItem(container, position); String title = mList.get(position); f.setTitle(title); return f; } @Override public int getItemPosition(Object object) { return PagerAdapter.POSITION_NONE; } "},"第4章_AndroidUI/第1节_Fragment/2_fragment的onResume，setUserVisibleHint，onHiddenChanged，isVisible方法.html":{"url":"第4章_AndroidUI/第1节_Fragment/2_fragment的onResume，setUserVisibleHint，onHiddenChanged，isVisible方法.html","title":"2_fragment的onResume，setUserVisibleHint，onHiddenChanged，isVisible方法","keywords":"","body":"fragment的setUserVisibleHint，onResume,onHiddenChanged三个方法的应用与之间的区别 要搞明白setUserVisibleHint 、onResume、onHiddenChanged之前，我们先回顾下fragment的其中两种加载方式：一，普通加载 二、懒加载，而懒加载的重要实现方式之一viewpager+fragment组合。 1、普通加载用的是hide()和show方法，因此与之关联的方法是onHiddenChanged()，而onUserVisibleHint()在此fragment中不会运行。 2、懒加载用于刷新数据的方法是setUserVisibleHint()，而onHiddenChanged()在此fragment中不会运行。 3、至于fragment中onResume()的用法。先看fragment的生命周期 fragment的onResume()方法跟activity的onResume()方法运行的节奏是一致的，activity是从不可见到可见，能实现人机交互，一定会运行onResume()方法。但是fragment由不可见到可见状态，能实现人机交互，但是却不一定会走onResume()方法，因此有时候fragment从不可见状态到可见状态时，想要数据刷新，只依赖onResume()是不可行的。于是有了onHiddenChanged()和setUserVisibleHint结合使用，才能达到我们想要刷新数据的目的。 总结，当fragment中的setUserVisibleHint()、onHiddenChanged()、onResume()其中一个方法“单纯”运行时，其他两种方法都不会再运行。 "},"第5章_JAVA知识/1_Sychronize同步机制总结.html":{"url":"第5章_JAVA知识/1_Sychronize同步机制总结.html","title":"1_Sychronize同步机制总结","keywords":"","body":"synchronized 参数 及其含义 转自：https://blog.csdn.net/a1064072510/article/details/84065646 这个想必大家都不陌生，java里面的重量级锁。用来控制线程安全的。在long And long ，我刚开始接触java的时候 ，我就对这个关键词好奇颇深。尤其是 它的参数，有this的 也有静态变量的。网上对这个参数解释又太过术语话。 例如： 作用于方法时，锁住的是对象的实例(this)； 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程； 当作用于一个静态类的时候，不管是不是本身内部的静态类，还是别人的静态类，都可以完成锁住的效果（ps 上锁的时候，相当于一群人 拿把锁找个东西上锁 synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。 这不管是对于初学者，还是老鸟 。都感觉沉长无味。 最近，我的项目涉及到这一块，我对这个方法有了顿悟，写下来 传之后世 我对这个参数的理解是这样的。 synchronized(获取锁的地方){ 工作内容 } 是的 ，你们没看错 （）里面的就是一个“获取锁的地方”。{ }里面是工作内容。 他们有这几条关系。 获取锁的地方 和 工作内容 是不必需要 有任何关联的。 可以有关联，但没有关联 也没事 获取锁的地方 ：只是一个让synchronized 整体 放置锁的地方，一个“获取锁的地方” 只有一把锁。 工作内容： 要进行工作的**前提是 synchronized整体，找到一个“获取锁的地方”，在 “获取锁的地方” 获取到了锁， 如果 “获取锁的地方”的锁，已经被别人拿去了，那么就只能等待别人 把锁还给 “获取锁的地方”。然后 再获取锁。 synchronized 会使用运行工作内容的前提，必须获取到锁。这个意思呢，就是例如，当前线程synchronized 获取到了objec A的锁，那么其他线程还可以更改 A 进行操作么?。 这个得到分两种情况，如果其他线程代码 是被synchronized 所包裹的，那么只能等 objec A被释放了，才能更改。如果，其他线程代码没有被synchronized包裹，她可以不需要有锁，就可以对objec A进行操作。 解释 先打个比方，我们把 synchronized这个看成一个整体，那么在多线程的时候，就会有很多个 synchronized整体。 这个整体开始工作的前提是 它可以从 “获取锁的地方”拿到锁。那么他就可以做工作了。如果 想要 “获取锁的地方”的锁，已经被别人拿走了。那么只能等别人把锁换回来，才行。。 上面这个还是有点抽象。就这么说吧 在程序运行多线程的，会产生好多synchronized整体。就叫小明，小红，小芳，小花…等。他们现在手中没有锁，只有手中有锁的时候 才可以工作。 现在小明，小红他们来到工作的地方。获取锁的地方就是路边的一棵树：：注意现在路边只有这一棵树。小红抢先一步将树上的锁拿走了。然后小红工作去了（她的工作 不用和树有关系，她可以砍树，也可以去路边扫地 ）。小明，小芳等其他人，因为没地方获取锁（只有一棵树 并且树的锁 已经被小红拿走了）。所以只能在原地等待 ，小红工作做完了 把锁还给树 ，小明，小芳才有机会进行工作。、 注意： 上面是路边只有一棵树，如果存在好几颗树的话，那么小明，小红他们就可以同时放置获取锁 一个数对应一个锁，多个树就多个锁。这个对应于类的实例 （实例可以有好多个） 验证 我们首先定义一个Runnable ，因为 多线程的话 最好还是用Runnable,至于为什么呢？百度去。 static class LockRunable implements Runnable { private int num; private LockNormal lockNormal; public LockRunable(int num, LockNormal lockNormal) { this.num = num; this.lockNormal = lockNormal; } @Override public void run() { while (true) { if (num 这个类呢 接受一个整数，一个LockNormal我自己定义的类，在run里面呢先对 num进行判断小于等于0的话，就退出，否则减一。 运行一下 LockNormal lockNormal = new LockNormal(); LockRunable one = new LockRunable(15, lockNormal); new Thread(one).start(); new Thread(one).start(); new Thread(one).start(); new Thread(one).start(); new Thread(one).start(); num竟然变成负的了，这是因为 五个线程同时对他进行操作，造成的。要避免这种情况，只能一个线程操作的时候，别的线程就不能操作。 我们给程序加锁试一下。首先定义一个 静态成员，静态成员有一个特点是系统初始化的，全局只有一个实例。就相当于上面的 只有一棵树。 static final transient Object lock = new Object(); 对 工作内容加锁 @Override public void run() { while (true) { synchronized (lock) { if (num 运行 这次就和预期结果相等了。但是 我们可发现 都是都是同一个线程进行操作的，这是因为 sleep时候不会释放锁，其他线程也无法进行操作 传入实例 static class LockRunable implements Runnable { private int num; private LockNormal lockNormal; public LockRunable(int num, LockNormal lockNormal) { this.num = num; this.lockNormal = lockNormal; } @Override public void run() { while (true) { synchronized (lockNormal) { if (num 结果： 也是同样的结果，如果 我们传入this的话 运行还是一样的结果。这就是上面树的问题了，不管是传入的实例，还是this本身实例。只有能保证它们本身是唯一的，也就是“获取锁的地方”只有一个，同一时间内只有一个人能成功获取到锁 进行工作。就和锁静态成员是一样的效果如果我们 new 两个Runnable的话，并且传入this实例的话，就会有两个“获取锁的地方” ，可以有两个人同时工作。 总结 synchronized(放锁的地方){ 工作内容 } 只要我们保证“获取锁的地方”是唯一的，那么在同一时刻，就只能有一个工作内容会被执行。如果，“获取锁的地方”不是唯一的（一个类new很多实例，锁住this实例，那么同一时刻就会有很多放锁的地方），在同一时刻就会有好多 工作内容被执行。 "},"第6章_技巧/1_app反调试.html":{"url":"第6章_技巧/1_app反调试.html","title":"1_app反调试","keywords":"","body":"反调试方法 1、判断是否有调试器连接： Debug.isDebuggerConnected()；2、判断是否被其他进程跟踪（使用Ptrace方式跟踪一个进程时，目标进程会记录自己被谁跟踪，通过查看 /proc/pid/status 中 tracerPid 是否为 0）；3、每个进程同一时刻只能被1个调试进程ptrace，主动ptrace本进程可以使得其他调试器无法调试；4、检测是否在非 Debug 编译模式下，进行了调试操作；5、一般调试都是在设备被 root条件下，所以可以检测设备是否被 root ，如果存在风险就退出应用。 "}}